Python



Python - объектно-ориентированный язык программирования.
Все сущности в Python - объекты (это и функции, числа, строки и все остальное).
Класс - это шаблон или прототип для создания объектов.
На основании одного класса можно создать много объектов.
У каждого объекта есть атрибуты.
Атрибут объекта называется методом, если его значение - функция.
PEP8 - советы по написанию кода для красоты и читабельности
Python - язык с динамической типизацией. (можно присваивать переменной много 
значений и при этом значение переменной будет каждый раз меняться)

Советы по написанию кода:
      1. Для отступов использывать пробелы
      2. Строки не больше 79 символов
      3. Функции и классы должны быть отделены от других строк кода двумя 
        пустыми строками
      4. Импорты модулей должны бьть на отдельных строках
      5. Комментарии в конце строки кода должны отделяться двумя пробелами 

Основные типы сущностей:
    - строка str 'Text'; 'string'
    - целое число int 10; -5; 40
    - логический(булевое значение) bool True; False
    - список list [1, 2, 3]; ['element', 1, False]
    - словарь dict {'notebook': 7, 'pen': 5}



Встроенные функции
      Вызов функции 
     ↓            ↓
print("Hello Dima")
  ↑          ↑
Встроенная   Аргумент
функция      (Значение типа str)

Примеры встроенных функций: 
print() type() id()
len() sum() input()
round() min() max()
int() str() bool()

Встроенная функция 

Встроенная функция input()

name = input("Введите значение name: ")
print(name)

   - создает поле ввода в терминале 
   - с помощью кавычек можно добавить текст (в данном случае это "Введите значение name: ")
   !!! всегда возвразает строку !!!


Встроенная функция dir()

name = 'Whale'
print(dir(name))

    - отображает все атрибуты объекта
    - атрибут объекта называется методом, если его значение - функция. 
      Соответственно этот метод можно применить на данный объект
--------------------------
['__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__',
'__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getstate__',
'__gt__', '__hash__', '__init__', '__init_subclass__', '__ior__', '__iter__', '__le__', '__len__',
'__lt__', '__ne__', '__new__', '__or__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__',
'__ror__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy',
'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
__class__ - магических метод и атрибуты
get - методы
--------------------------
С помощью print(dir()) можно посмотреть все переменные в данной области видимости

Встроенная функция id()

id(name)
Возвращает идентификатор (id) объекта в памяти

Встроенная функция type()

type([1, 2, 3])
Возвращает тип объекта (str, int, list...)

Встроенная функция eval()

result = eval('1+1')           calculater = eval('first-second')
print(result)                  print(calculater)
  - Решает выражения

Встроенная функция help()

help(print)
  - показывает документацию о модуле, функции или о любом другом

Встроенная фукция zip()

fruits = ["banana", "apple", "orange"]
prise = [200, 100, 50]
zip(fruits, prise)
  - создает зип объект, из одной или нескольких последовательностей, который содержит в себе группы элементов (в виде кортежей)
Пример:
fruits = ["banana", "apple", "orange"]
prise = {200, 100, 500, 400}
zip_ob = zip(fruits, prise)
print(set(zip_ob)) # {('apple', 100), ('banana', 200), ('orange', 500)}

Встроенная функция isinstance()

print(isinstance(1, int))         # True
print(isinstance('Hello', list))  # False

  - проверяет принадлежит объект классу

Встроенная функция filter()

filter(Функция, Последовательность)

Применяет функцию ко всем элементам последовательностей



Встроенные фукции для строк

len('Whale') - возвращает количество символов строки

name = "Sea Team"
print(name[0]) - возвращает символ строки, отсчет идет от 0
print(name[1:3]) - возвращает часть строки, отсчет идет от 0
print(name[0:]) - возвращает с какого-то символа до конца работает и в противоположном случае (:4)


Как вызвать метод?

name = 'whale'

print(name.upper())
            ↑
        это метод upper 
        - тут также добавлены скобки после метода для его вызова
        - метод upper делает все буквы большими (тоесть в терминале в данном случае будет WHALE)

!!! методы не могут создавать объекты !!!


Функции

Функция - блок кода, который можно выполнять многократно
Функция это объект, как и все в питоне
-------------------------------------
def sum(a, b): 
  c = a + b
  print(c)
print(type(sum))  #<class 'function'>
-------------------------------------

Функция возвращает None если нет ключевого слова return
Функцию надо вызвать для выполнения кода внутри функции

-------------------------------------
def my_fn(a, b):    
  a = a + 1
  c = a + b           ← Объявление функции
  return c      

res = my_fn(10, 3)    ← Вызов функции
print(res)
-------------------------------------

     Имя   Параметры
      ↓      ↓
def editor(a, b):
    a = a + 1
    c = a + b  ← Тело функции
    return c 
      ↑ 
    Возврат результата
 ↑ 
!Обязателен отступ в 4 пробела

 Скобками вызываеться функция и в них пишуться аргументы (так же как и во встроенных функциях)
      ↓
editor(3, 4)  
   ↑
Имя функции

Параметр - это переменная доступная только в функции. При вызове функции в 
скобках надо обязательно указывать аргумент если в функции есть параметр

return - это ключевое слово которое пишется внутри тела фукции и возвращает одно значение из функции.
После написания return в функции она прикращает свою работу.

pass - это ключевое слово, у функции должно быть тело, если его нет, но функцию создать нужно, можно прописать вместо тела ключевое слово pass (его можно использывать также в циклах)

Самая короткая функция:
def my_fn():
  pass

print(my_fn()) # None

f"" - функция для динамического формирования строк с динамическими выражениями
-------------------------------
def get_posts_info(name, posts_qty):
  info = f"{name} wrote {posts_qty} posts"
  return info

info = get_posts_info('Bogdan', 25)
print(info)
-------------------------------


Аргументы функции

Аргументы указываются во время вызова фукнции

my_fn(first_argument, second_argument)
      Позиционные аргументы (потому что порядок важен, ecли поменять их местами результат изменится)
        ↓  ↓
sumnums(2, 3)
--------------------------------------------
def get_posts_info(name, posts_qty):
  info = f"{name} wrote {posts_qty} posts"
  return info

info = get_posts_info(posts_qty=25, name='Bogdan')  # аргументы с ключевыми словами, порядок не важен
print(info)
--------------------------------------------

Функция может принимать любое количество аргументов, если объединить их в кортеж следующим образом:
def sum_nums(*args):
  print(args)       # (2, 3, 7)
  print(type(args)) # <class 'tuple'>
  return sum(args)

print(sum_nums(2, 3, 7)) # 12

Аргументы функции также можно объеденять в словарь
--------------------------------------------
def get_posts_info(**person):
  print(person)
  #{'name': 'Bogdan', 'posts_qty': 25}
  print(type(person)) # <class 'dict'>
  info = (                         # это не кортеж
    f"{person['name']} wrote"       # пайтон автоматически объеденил две строки с помощью такого синтаксиса
    f"{person['posts_qty']} posts"
  )
  return info
info = get_posts_info(name='Bogdan', posts_qty=25) # обязательно нужно использовать аргументы с ключевыми словами  
print(info)
--------------------------------------------

Можно сделать дефолтное значение аргументов, но они станут не обязательными
                            Значение по умолчанию
                                    ↓         
def counter(name, password, email=None):
  pass


Колбэк функции

Колбэк функция - это функция, которая должна быть выполнена после того, 
как другая функция завершила выполнение (отсюда и название: callback — функция обратного вызова)
Пример:
-------------------------------------------------
def print_number_info(num):
  if (num % 2) == 0:
    print("Entered number is even")
  else:
    print("Entered number is odd")

def process_number(num, callback_fn):
  callback_fn(num)

entered_num = int(input("Entered any number: "))

process_number(entered_num, print_number_info)
-------------------------------------------------

Документация функции (Docstring)

Docstring используется для документирования функции, классов, модулей
-------------------------------------------------
def mult_by_factor(value, mult=1):
  """Multiplies number by multiplicator"""   # описание функции, оно вылезет принаведении на функцию
  return value * mult

  
mult_by_factor(5)


Комментарии 
 
# Однострочный конмментарий

# Многострочный 
# комментарий


Выражения (на англ expressionss)

Результатом выражения является значение.

Примеры выражений:
5 + 3  # результатом будет значение 8
31 > 27  # результатом будет значение True
'Sea' + 'Team' # результатом будет значение 'Sea Team'


Инструкции (на англ statements)

Инструкция выполняет действие.

name = 'Whale'  # присвоение значения

Примеры инструкций:

if name: 
    print(name)  # условие

import tkinter  # импортирование


Инструкция del (НЕ ОПЕРАТОР)

Примеры использования:
del my_dict['a'] # my_dict.__delitem_('a')


Переменные

Как называть разные переменные в питоне?

snake_case  # таким форматом можно называть переменные, функции, методы, модули
PascalCase  # таким форматом можно называть классы, слова нужно писать слитно 
              и каждое слово с большой, при этом первое слово также с большой
my-package  # таким форматом можно называть пакеты
DB_PASSWORD  # константы (не изменяемые переменные на протяжении работы программы) 

Примеры присвоения переменных 

text = 'sea'
number = 10
bool = True
result = function(10, 35)
list = [1, 2, 3]
dictionary = {"youtube": 1, "telegream": "second"}

Названия переменных это ссылки на объекты в памяти. (Все в питоне объекты)

В питоне есть изменяемые и неизменяемые объекты:
    - Неизменяемые:
      string (строка)
      boolean (булевое значение)
      integer (целое число)
      float (число с десятичной дробью)
      tuple (кортеж)
      ...
    - Изменяемые:
      list (список)
      dictionary (словарь)
      set (набор)
      user-defined classes (пользоваттельские классы)
      ...

!!! Неизменяемые объекты создаються в памяти один раз
--------------------------------
a = 10
b = 10

print(id(a) == id(b))  # True
--------------------------------



Строки (класс str)

Любая строка - экземпляр класса str (встроенный класс)
Строка - последовательность символов
'' - используют для строк с 1 словом
"" - для многословных строк
"""Для многострочных строк исполюзуют
три кавычки подряд, как здесь"""

Методы для строк

.upper() - делает все буквы БОЛЬШИМИ
.replace('что заменять', 'на что заменить', 4) - выводит часть строки с изменениями (4 это сколько раз заменить часть) 
(не изменяет переменную)
-------
text = "pronunciation"
print(text.replace('o', '_', 2))
# pr_nunciati_n
-------
.index('что искать', 2, 4) - выводит номер символа 
(2 и 4 это с какого по какой символ иксать если не писать тогда будет исать по всей строке)
.capitalize() - делает первую букву большой
.lower() - делает все буквы маленькими (нижний регистр)
.count('что считать') - считает количество чего-то
-------
str = "Pharmacy"
print(str.count('P')) # 1
-------

str(123) - встренная функция, преобразует указанное значение в строку 


Целые числа (класс int)

int('123') - встренная функция, преобразует указанное значение в число
  - преобразует только строки состоящие из цифр 
  и логические значение (True или False), результатом будет 1 или 0
pow(4, 2) - встренная функция, возводит в степень  (4²)   

Числа с точкой  (класс float)

round(number, 1) - встроенная функция, округляет число до едениц (из float делает int)
(можно также указать до какого числа округлять, изначально это 0)
------------------------------------
print(round(123456.789, 2))         #123456.79
print(round(123456.789, -3))        #123000.0
------------------------------------
float('45.99') - встренная функция, преобразует указанное значение 
в число с точкой (удаляет без правил сокращения часть после точки)


Комплексные числа(класс complex)

Используються для математических вычеслений, а также при обработке данных.
Комплексное число состоит из действительной и мнимой частей.

                Мнимая
                 ↓ 
complnumb = 5 + 3j
            ↑
        Действительная часть

Особенности:
comlex_a = 10 + 7j
comlex_b = 3 + 3j

print(comlex_a * comlex_b)    # ответ (9+51j)

                              # (10 + 7j)(3 + 3j)


Логические (булевые) значения   (класс bool)

print(100 > 24) # True
print(-5 > 0)   # False
print('Long string' > 'Short string') # False
print(bool('Long123123123' > 'Long')) # True, сопоставляет символы с каждой строки, если ошибок нет тогда True
print([1, 2, 3] == [1, 2, 3]) # True

bool() - встроенная функция, конвертирует в логическое значение


Списки (класс list)

Список - это упорядоченная последовательность элементов
Примеры:
  fruits = ['apple', 'banana', 'lemon']
  numbers = [6, 7, 8]
  list = [True, 'Whale', 10, []]
Порядок в списке имеет значение!

len() - возвращает кол-во елементов списка
------
len([True, False, 'Chtoto'])  # 3 елемента
------

У каждого елемента есть свой индекс и по нему можно отобразить объект
list = ['whale', 'dolphin', 'clown-fish']
print(list[0])    # выведется 'whale'
print(list[1])    # выведется 'dolphin'
print(list[-2])   # выведется 'dolphin',  - означает что отсчет с конца
print(list[1:])   # выведется 'dolphin', 'clown-fish'   :означает что выведется все с определенного объекта 
                    в плоть до конца (или начала) 
      - отсчет идет с нуля    
Таким же образом можно изменять объекты в списках
blocks = ['He', 'She', 'It']
blocks[2] = 'You'
С помощью оператора del можно удалить объет из списка
del company[1] 
--------------
list = [
    {
        'apple':123,
        'orange':456
     },
    {
        'pineapple':789,
        'lime':101
     },
]
print(list[1]['lime']) #101   
--------------
Методы списков
.append() - добавляет элемент в конец списка
.pop() - удаляет элемент по индексу, если не указать будет удален последний элемент
.sort() - сортирует объекты списка, если не указать аргументы то отсортируется по возростанию
          если указать в аргументе reverse=True отсортирует по убыванию
.copy() - копирует список ()
.insert(2, 'Hello') - добавляет элемент перед определенным индексом
.clear() - очищает список (нет аргументов)
.extend() - объеденяет списки, также может вставлять строки по символам пример:
      list = [1, 2, 3]
      list.extend("Hello")   #[1, 2, 3, 'H', 'e', 'l', 'l', 'o']
.reverse() - меняет последовательность в списке наоборот ы


Встроенная функции для list
list() - превращает в список
________________
string = "Hello"
list = list(string) # ['H', 'e', 'l', 'l', 'o']
dict = {'a': 10, 'b': True}
list = list(dice)   # ['a', 'b']
________________
min() - минимальное значение
max() - максимальное значение
sum() - сумма значений


Словари (dict) 
              Ключ  Значение
                ↓    ↓
dict = {"a": 1, "b": True}

Ключи должны быть между '' или ""

dict["a"] - выводит значение по ключу
dict["a"] = 1   - изменение по ключу
dict["с"] = True - добавление новых элементов
del dict["a"]    - удаляет элемент   

len() - возвращает кол-во елементов словаря

Методы для словарей 
.get() - возвращает значение по ключу
      Если элемента с таким ключом нет вернет None (можно указать вторым аргументом что выводить вместо None)

Кортежи (tuple)

Кортеж - упорядоченная последовательность элементов, отличается от списков тем, что кортежи нельзя изменять
Пример:
tuple_num = (221, 222, 223)
fishes = ("Fish1", "Fish2", "Fish3")
info = (True, 1, "text", [4, 5, 6])

len() - возвращает кол-во елементов кортежа

tuple[0] = True   #возвращает элемент кортежа
-------------------
firstuple = (1, True, "Hello")
sectuple = ([0], 1.5, {4: 5})
result = firstuple + sectuple
print(result) # (1, True, 'Hello', [0], 1.5, {4: 5})
# Объединение кортежей
# Не забываем что при использовании оператора + вызываеться магический метод __add__
-------------------
У кортежей есть только 2 метода:
.count(True)    - возвращает колво таких элементов в кортеже
.index("whales")    - возвращает индекс элемента в кортеже

С помощью tuple() можно сделать объект кортежем 


Наборы (set)

Наборы это неупорядоченная (последовательность не имеет значения) последовательность элементов
Наборы содержат только уникальные значния
Изменять наборы можно
В наборах обычно сохраняют однотипные данные

Пример:
set_withfruits = {'apple', 'banana', 'orange'}
posts_numbers = {226, 227, 228}

!!!Важно!!!

Набор вида {112, 112, 114, 114} можно создать, но если вывести его в терминал, 
будут видны только неповторные элементы

print({112, 112, 114, 114})  # {112, 114}

Поэтому наборы можно использовать для нахождения одинаковых значений
Наборы {"apple", "banana", "orange"} и {"banana", "apple", "orange"} одинаковые потому, что порядок не важен
len() - длина набора
У элементо набора нет индексов поэтому
fruits[2] - это ошибка (тоесть у наборов нет магического метода __getitem__)

! В наборы нельзя добавлять изменяемые объекты (list, dict...)
Методы наборов:
.add() - добавляет элемент в набор
.union() - объеденяет наборы (тоже самое можно сделать таким образом set1 | set2)
.intersection() - пересичение двух наборов (элементы которые есть и в первом, и во втором наборах)
(тоже самое можно сделать с помощью set1 & set2)
.issubset() - проверяет содержит ли набор элементы другого набора
------------------------------
st1 = {1, 2, 3}
stall = {1, 2, 3, 4, 5, 6}
print(st1.issubset(stall)) #True
------------------------------
.discard() - удаляет элемент из множества (если нет элемента вернет None)
    - оператор del не работает на наборы
.remove() - удаляет элемент из множества (если нет элемента будет ошибка  
.copy()
.symmetric_difference - выводит элементы которые не относяться к пересичению (пересичение это элементы которые есть в обоих набоарх)


Диапазоны (range)
Диапазон это упорядоченная, неизменяемая последовательность элементов
Диапазоны используются в циклах
Пример:
range = range(3, -7)     # 3, -7
price = range(10)        # 0, 10
percent = range(-4)      # 0, -4
example = range(-1, 2)   # -1, 2

Из диапазона в список
range = list(range(3, -7))      # []
price = list(range(10))         # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
percent = list(range(-4))       # []
example = range(-1, 2)          # [-1, 0, 1]           
             Шаг
              ↓
range(10, 20, 3)                #[10, 13, 16, 19]
Так как диапазоны это упорядоченная последовательность можно получать элементы по индексу
my_range = range(10, 20, 3) 
my_range[0] #10
my_range[1] #13
my_range[2] #16
my_range[3] #19

Методы диапазонов:
.index() - выводит индекс задонного числа
.count() - выводит колво задонного числа (так как в диапазоне все элементы уникальны может вывести только 0 или 1)
 


Конвертация значений
Python не выполняет неявную конвертацию типов значений.
 
"5" + 4 = Ошибка    # это не явная конвертация
7 + True = 8        # булевые значения также можно распознавать как 0 и 1

Последовательности:
        Именяемость   Упорядоченность  Одинаковые элементы
list    ✅             ✅                ✅
tuple   ❌             ✅                ✅
set     ✅             ❌                ❌
range   ❌             ✅                ❌
dict    ✅             ❌                ❌
str     ❌             ✅                ✅


Области видимости

Области видимости определяет границы действия переменной 
-----------------------------------------------------
a = 10            Глобальная область видимости

def my_fn():      Область видимости функции
  a = True
  b = 15
  print(a) # True
  print(b) # 15

my_fn()

print(a) # 10
print(b) # NameError: name 'b' is not defined
-----------------------------------------------------
Типы областей видимости:
  Глобальная область видимости
  Область видимости функции

В пайтоне можно создать глобальную переменную в функции
-------------------
a = 5

def my_fn():
  global a        # Для этого используем ключевое слово global
  a = 10          # global делает переменную глобальной области видимости, но не объявляет ее


my_fn()

print(a) # 10
-------------------


Ложные значения 

Значение, которое при приведении к логическому типу дает False, является ложным
Ложные значения:
int       0
float     0.0
complex   0j
bool      False
NoneType  None
dict      {}        # пустые последовательности
list      []
tuple     ()
set       set()
range     range(0)
str       ""

Чтоб проверить ложное ли значение достаточно просто вызвать встроенную функцию bool(),
ложным оно будет если выведет False



Операторы

Оператор (бинарный потому, что два операнда)
  ↓
a = 10
↑    ↑
Операнды

Арифметические операторы:
+ - * /
Операторы сравнения (результат True или False):
== != < >
Логические операторы: 
not and or
Оператор присвоения:
=

Текстовые операторы:
not and or
  id   is not
in  not in


is - проверяет совпадают ли объекты (совпадают если айди объектов в памяти одинаковые)
----------------------------------------------------
a = 10 
b = a
c = a + b

print(a is b)  # True
print(c is a)  # False
----------------------------------------------------

При вызове операторов вызываеться магический метод.
И соответственно каждому оператору совпадает магический метод.
Например:
  == и __eq__

Операторы:
  Унарные
  Бинарные 

Унарные операторы:
+   -  not

Бинарные операторы:
= += == and

Для определения последовательности операторов нужно использовать скобки:

a + b * c / b - e  =>  a + ((b * c) / (b - e))


Логические операторы(not and or)

not - выдает True, если его операнд False, и False в противоположном случае
Оператор not чаще всего используется в условных конструкциях if

Операторы and и or являются операторами короткого замыкания (short-circuit)
Оператор and - который выводит одно ложное выражение из всех, если все выражения ложные выведет первое, если все True выражения выведет последнее
Выражение1 and Выражение2 and ...
а
Оператор or - тоже самое что и and только выводит положительное выражения
Выражение1 or Выражение2 or ...


Оператор распаковки словаря **

--------------------------------------------
button = {
    "width": 200,
    "text": "Buy"
}

red_button = {
    **button,           # распаковуем словарь button в словарь red_button
    "color": "red"      # таким образом копируем все ключи-значения в red_button
}
--------------------------------------------

Объединение словарей
--------------------------------------------
book_one = {
    'width': 200,
    'color': 'red'
}

book_two = {
    'text': 'Hello',
    'title': 'Kruti kniga'
}

libr = {
    **book_one,
    **book_two
}

# or

libr = book_one | book_two
--------------------------------------------

Соединение строк

'Hello ' + 'Python' # 'Hello Python'
                    # __add__()

Форматирование строк

--------------------------------------------
hello = 'Hello' 
world = 'World'

greeting = f"{hello} {world}"  # в curly brackets может быть что-угодно
# Также для абзаца в таких строках можно использовать \n
# Также чтоб добавить в строку ' или "" можно использовать esc-символ \
print(greeting) # Hello World 
--------------------------------------------


Магические методы

Магические методы - это методы определенные на уровне класса 
    - в названии магического метода всегда есть два знака  подчеркивания (__init__)

__add__() - выполняет + (при использовании оператора + вызываеться магический метод __add__)
----------------------------------------
firstvalue.__add__(secondvalue)
----------------------------------------

__getitem__ - выполняет функцию []  (при вызове list[0] вызываеться этот магический метод)
----------------------------------------
list.__getitem__(0) #и list[0] это одно и тоже
----------------------------------------

__str__() - конвертация в строку


Лямбда функции

      Параметры (можно перечислить несколько через ,)
          ↓
lambda parameters: expression
  ↑                     ↑
Ключевое слово       Допускается только одно выражение

Лямбда функции всегда анонимные, тоесть без имени
Лямбда функции не рекомендуется присваивать переменным (PEP8)

----------------------------------------
result = lambda a, b: a * b       # ❌

print(result)

def trueresult(a, b):             # ✅
  return a * b   

print(trueresult)
----------------------------------------

Пример использования лямбда функции
----------------------------------------
def greeting(greet):
    return lambda name: f"{greet}, {name}"


morning_greeting = greeting("Good Morning") # теперь эта переменная лямбда функция 

print(morning_greeting('Dima'))

print(morning_greeting('Ivan'))
----------------------------------------


Обработка ошибок

try:
    # Выполняет блок кода
    pass
expect ErrorType:  # тип ошибки который обрабатывается 
    # Этот блок выполняется в случае ошибки
    pass

Обработка ошибки деления на ноль
----------------------------------------
try:
    value = 256
    zero = 0
    result = value / zero
except ZeroDivisionError:
    print("На ноль делить нельзя") 
----------------------------------------

Если обработать ошибку то код не будет прекращать работу после ошибки.

Можно вывести текст об ошибки из самой ошибки
----------------------------------------
try:
    value = 256
    zero = 0
    result = value / zero
except ZeroDivisionError as error:
    print(type(error))
    # <class 'ZeroDivisionError'>
    print(error) # division by zero
----------------------------------------

Обработка нескольких видов ошибок
----------------------------------------
try:
    value = '256'
    zero = 0
    result = value / zero
except ZeroDivisionError as zero_error:
    print(type(zero_error))
    # <class 'ZeroDivisionError'>
    print(zero_error)  # division by zero
except TypeError as type_error:
    print(type_error)  # unsupported operand type(s) for /: 'str' and 'int'
----------------------------------------

Также к try except можно добавить else
----------------------------------------
try:
    value = '256'
    zero = 0
    result = value / zero
except ZeroDivisionError as zero_error:
    print(type(zero_error))
    # <class 'ZeroDivisionError'>
    print(zero_error)  # division by zero
except TypeError as type_error:
    print(type_error)  # unsupported operand type(s) for /: 'str' and 'int'
else:
    print("Unknown error")  # выполняется в случае всех других ошибок    
----------------------------------------

И еще можно добавить finally
----------------------------------------
try:
    value = '256'
    zero = 0
    result = value / zero
except ZeroDivisionError as zero_error:
    print(type(zero_error))
    # <class 'ZeroDivisionError'>
    print(zero_error)  # division by zero
except TypeError as type_error:
    print(type_error)  # unsupported operand type(s) for /: 'str' and 'int'
else:
    print("Unknown error")  # выполняется в случае всех других ошибок
finally:
    print("Проверка на ошибки завершена")  # выполняется в любом случае
----------------------------------------


Отсутствие типа ошибки и класс Exception

Если не знаешь какая ошибка будет можно использовать следующий синтаксиса
----------------------------------------
try:
    print(10/10)
except Exception as error:    # Exception это родительский класс для всех классов ошибок
    print(error)

try:                
    print(3*2)
except:                   # так делать не рекомендуется
    print('Error') 
----------------------------------------


Создание ошибок

-------------------------------------------------
def divide_nums(a, b):
    if b == 0:
        raise TypeError("Second argument can\'t be 0")  # создаем ошибку если b == 0
    return a / b


try:
    divide_nums(10, 0)
except TypeError as error:                              # обрабатываем ошибку
    print(error)  # Second argument can't be 0
-------------------------------------------------

Распаковка (list, tuple)

---------------------------------------
indexes = [45, 46, 47, 48]                # здесь может быть либо список либо кортеж

first, second, third, fourth = indexes    # присваиваем переменным значения списка
                                          # Важно чтоб переменных было столько же сколько элементов в списке
---------------------------------------

Распаковка с помощью оператора *
---------------------------------------
indexes = (45, 46, 47, 48)                # здесь может быть либо список либо кортеж

first, *others = indexes                  # помещаем все оставшиеся элементы в список others
---------------------------------------

Распаковка словаря в аргументы с ключевыми словами
---------------------------------------
user_profile = {
    'name': 'Dima',
    'comments': 13
}


def user_info(name, comments=0):            # параметров должно быть столько же сколько и ключей в словаре 
    if not comments:                        # для распаковки словаря в функции
        return f"{name} has no comments"

    return f"{name} has {comments} comments"


print(user_info(**user_profile))
---------------------------------------

Распаковка списка в позиционные аргументы
---------------------------------------
def counter(value, degree):
    result = value ** degree
    return result


task_one = [2, 3]
task_two = [4, 2]
task_three = [15, 0]

print(counter(*task_one))
print(counter(*task_two))
print(counter(*task_three))
---------------------------------------

Условные инструкции

if    if ... else   if ... elif   Тернарный оператор

  Любое выражение
      ↓
if Условие:
    # блок кода
    pass          ← выполнится если условие True

Приме:
----------------------------------------
my_number = 5

if my_number > 0:
  print(my_number, "is positive number")
----------------------------------------
И еще 
----------------------------------------
person_info = {
  'age': 13
}

if not person_info.get('name'):
  # выполнится если такого ключа нет или если значение ключа ложное
  print("Имя отсутствует")
----------------------------------------

if Условие:
    # Выполняется если условие правдиво
else:
    # Выполняется если условие ложно

Пример:
----------------------------------------
my_number = 21.5

if type(my_number) is int:
    print(my_number, "is integer")
else:
    print(my_number, "isn\'t integet")

# 21.5 isn't integet
----------------------------------------

if Условие_1:
    # Выполняется если условие правдиво
elif Условие_2:
    # Выполняется если предедущие условия ложны, а это правдиво
else:
    # Выполняется если все условия ложны

Пример:

my_number = 21.5
----------------------------------------
if my_number > 0:
    print(my_number, "is positive")
elif my_number < 0:
    print(my_number, "is negative")
else:
    print(my_number, "is zero")
----------------------------------------

Также можно создать условный оператор для проверки значения

match Перемення:
    case Вариант:
        Что делать если переменная соответствует ожиданиям


Example:

error = input()
match error:
    case 404:
        print("Not found page")
    case 400:
        print("I don't now this error")



Тернарный оператор (условное выражение)

У тернарного оператора три операнда.
Конструкция с тернарным оператором - выражение.
Результатом выражения есть значение.


Выражение_1 if Условие else Выражение_2
  ↑                             ↑ 
Если условие                  Если условие
правдиво,                     ложно,
возвращается                  возвращается
Выражение_1                   Выражение_2

Примеры:
----------------------------------------
print('Even') if int(22/2) != 22 / 2 else print('Odd')
----------------------------------------


Циклы

Циклы используются для перебора элементов последовательностей
(dict, list, tuple, set, range, str)

Типы циклов:
for ... in ...

while

Цикл for ... in ...

for Элемент in Последовательность:
    # действия с каждым элементом


Примеры:
-----------------------------------------------
list = [1, True, 'apple']
for e in list:    # переменная e находтся в глобальной области видимости
    print(e)      # и по окончанию цикла хранит последний элемент последовательности

tuple = ('Dima', 'Oleynik')
for e in tuple:
    print(e)

dict = {
    'name': 'Dima',
    'age': 13,
    'dream': None
}
for e in dict:
    print(e, dict[e])
-----------------------------------------------

Чтоб получить все значения из словаря, не только ключи можно использовать .items()
-----------------------------------------------
dict = {
    'name': 'Dima',
    'age': 13,
    'dream': None
}
for e in dict.items():      # Создает dictitem, который содержит кортежи ключ-значение
    key, value = e
    print(key, value)

# или же

for key, value in dict.items():      # Создает dictitem, который содержит кортежи ключ-значение
    print(key, value)
-----------------------------------------------

for in для наборов (неупорядоченная последовательность)
---------------------------------------------------------
set = {2156, 3784, 7492, 9472}
for e in set:
    print(e) 

# 3784
# 9472
# 2156
# 7492
---------------------------------------------------------

for in для строк
---------------------------------------------------------
str = 'Dmytro'
for e in str:
    print(e)

# D
# m
# y
# t
# r
# o
---------------------------------------------------------

for in для диапазонов(range)
Можно использовать для того чтоб выполнить каоето колво раз одно и тоже
---------------------------------------------------------
for e in range(3):
    print(e)

# 0
# 1 
# 2
---------------------------------------------------------


Цикл while

while Условие:    # пока условие правдиво цикл будет выполняться
    # Блок кода, выполняемый на каждой итерации

Пример:
----------------
i = 10

while i < 50:
    print(i)
    i += 10

----------------

Чтобы создать бесконечный цикл достаточно написать while True:

Чтобы выйти из цикла достаточно использовать ключевое слово break
Пример:
--------------------------
while True:
    value = input()
    if value == 'stop':
        break    # выходит из цикла при условии   
    
    print(value)
--------------------------

Ключевое слово continue начинает цикл заново
-------------------------------------------------------
import random    

random_num = random.randint(1, 5)

while True:
    numb = int(input("Guess the number from 1 to 5: "))
    if numb != random_num:
        print("Try again...")
        continue  # начинает цикл заново при условии 

    print("Congratulations!", random_num)
    break
-------------------------------------------------------

Сокращенный for in (comprehensions)

Используется для создания новых последовательностей

Выражение for Элемент in Последовательность if Условие
                                                ↑
                                              Опциональное условие
Пример со списком:
------------------------------------------------------------
list = [abs(num) for num in [-1, -2, -3, 5, 4, -3, 7, -8]] # abs выводит модуль значения
print(list)
# [1, 2, 3, 5, 4, 3, 7, 8]
------------------------------------------------------------

Пример со словарем:
------------------------------------------------------------
my_scores = {
    'a': 10,
    'b': 7,
    'm': 14
}

scores = {key: value * 10 for key, value in my_scores.items()}

print(scores)
------------------------------------------------------------

И еще пример: (создание словаря из списка)
------------------------------------------------------------
example_list = [24, 25, 26, 27]

result_dict = {str(example_list.index(e)): e for e in example_list}

print(result_dict)
------------------------------------------------------------


Декораторы

Декораторы это функции, которые увеличивают 

Это базовый пример работы декоратора

def func_decorator(func): # параметр функция
    def add_lines():      # дополняем функцию
        print('----------------')
        func()
        print('----------------')

    return add_lines      # возвращаем дополненную функцию


def hello_smbd():         # обычная функция
    print("Hello, Python")


result = func_decorator(hello_smbd)   # вызываем декоратор с функции и присваиваем все переменной

result()    # вызываем новую функцию

Декоратор с парметром

def func_decorator(func):
    def add_lines(*args, **kwargs):  # объеденяем позиционные аргументы в список *
        print('----------------')    # а с ключевым словом в словарь **
        func(*args, **kwargs)
        print('----------------')

    return add_lines


def hello_smbd(name):                # добавляем любой параметр
    print(f"Hello, {name}")


result = func_decorator(hello_smbd)

result('Dima')                       # передаем аргумент
# ----------------
# Hello, Dima
# ----------------

result(name='Python')                # передаем аргумент с ключевым словом,
# ----------------                   # важно чтоб оно совпадало c параметром в декорированной функции
# Hello, Python
# ----------------

Декоратор который будет выводить время работы функции

import time
# нужен для работы временем
# time.time() выводит текущее время


def func_decorator(func):
    def add_lines(*args, **kwargs):
        start_time = time.time()
        func(*args, **kwargs)
        end_time = time.time()
        # отнимаем время до и после функции чтоб получить время ее работы
        fn_time = end_time - start_time
        print(f"Time of working function {fn_time}")

    return add_lines


def hello_smbd(name):
    print(f"Hello, {name}")


result = func_decorator(hello_smbd)

result('Dima')
# Time of working function 4.291534423828125e-05
# 4.291534423828125e-05 = 0,00004291534424

В реальности таким образом 

result = func_decorator(hello_smbd)

Функции не декорируют, а делают вот так

@func_decorator  # применяем декоратор
def hello_smbd(name):
    print(f"Hello, {name}")



Импорты стандартных модулей. Команды import и from


В пайтоне для подключения модулей используется ключевое слово import

import модуль

Пример:

import math
import datetime

В данном примере переменная math ссылается на пространство имен, также как и datetime.
Мы можем просмотреть переменные, которые хранит в себе пространство имен math с помощью dir()

print(dir)
# ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', 
# '__package__', '__spec__', 'math']

print(dir(math))
# ['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 
# 'asinh', 'atan', 'atan2', 'atanh', 'cbrt', 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 
# 'dist', 'e', 'erf', 'erfc', 'exp', 'exp2', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 
# 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt', 'lcm', 
# 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'nextafter', 'perm', 'pi', 'pow', 
# 'prod', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'sumprod', 'tan', 'tanh', 'tau', 'trunc', 'ulp']

Все встроенные модули в пайтоне составляют его стандартную библиотеку.
Для избежанию ошибок имен можно использовать псевдонимы:

import math as matesha
print(matesha.pi) # 3.141592653589793

Но таким образом мы загружаем весь модуль, если нам нужно только конкретные переменные и функции
можно использовать выборочный импорт:

from модуль import переменные, функции

Example:

from math import pi


print(dir())
# ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', 
# '__name__', '__package__', '__spec__', 'pi']

print(pi)
# 3.141592653589793

Здесь важно понимать что переменные и функции теперь появляются в глобальном пространстве имен.
И при этом у нас нет переменной math в глобальной области видимости.
Тоесть и доступа к этому модулю у нас нет.
Псевдонимы можно использовать и при выборочном импорте.

from math import pi as chislo_pi


print(chislo_pi)
# 3.141592653589793

И чтобы испортировать все из нужного модуля в глобальную область видимости можно использовать *

from math import *


print(dir())
# ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', 
# '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'cbrt', 
# 'ceil', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 'dist', 'e', 'erf', 'erfc', 'exp', 'exp2', 
# 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 
# 'isclose', 'isfinite', 'isinf', 'isnan', 'isqrt', 'lcm', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 
# 'log2', 'modf', 'nan', 'nextafter', 'perm', 'pi', 'pow', 'prod', 'radians', 'remainder', 'sin', 
# 'sinh', 'sqrt', 'sumprod', 'tan', 'tanh', 'tau', 'trunc', 'ulp']

Такой импорт делать НЕ рекомендуется ведь мы вносим в глобальное пространство имен множество переменных
и функций, при этом даже не знаем большинства. И это может вызвать ошибки имен
Также импорт каждого нового модуля следует делать на новой строке.
Вот так:

import math, datetime, pprint

Делать не рекомендуется.
Также импорты следует делать в начале программы.


Импорты собственных модулей 

Мы можем прописывать собственные модули и также импортировать их.

- mymodule.py

NAME = 'Dmytro'


def check_name():
    print(NAME)

- 1.py

import mymodule


print(dir())
# ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__',
# '__name__', '__package__', '__spec__', 'mymodule']

print(mymodule.NAME)
# Dmytro

Также может случится ситуация двойного импорта, когда мы импортируем файл который импортирует другой.
Пример:

- mymodule.py

import math

NAME = 'Dmytro'


def check_name():
    print(NAME)


- 1.py

import mymodule


print(dir())
# ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__',
# '__name__', '__package__', '__spec__', 'mymodule']
print(mymodule.math.pi)
# 3.141592653589793

В этом примере также показано как получить доступ к модулям, которые мы импортируем в другие модули.

Чтобы импортировать модуль из другой директории следует нужно данный синтаксиc:

import folder.mymodule  # указываем путь через точку


print(dir())
# ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__',
# '__name__', '__package__', '__spec__', 'mymodule']
print(folder.mymodule.math.pi)  # и тоже самое используем при обращении к данному модулю 
# 3.141592653589793

Также при импорте всего файла он будет выполняться

- mymodule.py

import math

NAME = 'Dmytro'


def check_name():
    print(NAME)


check_name()

- 1.py

import folder.mymodule
# Dmytro

Модули должны содержать только объявление функций, но не их вызов.
В каждом файле есть переменная __name__, она выводит файл в который его импортируют.
Тоесть если при том же расположении добавить в mymodule строку

print(__name__)  # folder.mymodule

То она выводит folder.mymodule, если прописать эту строку в 1.py 

print(__name__) # __main__

С помощью этой переменной можно сделать проверку, файл запускается через импорт или сам по себе:

if __name__ == '__main__':
    print("You call this file from this file")

Файл не запустится несколько раз если несколько раз его импортировать.

Также прописывая

import модуль

Модуль будет импортироваться в виде байткода и для оптимизации дальнейшего импорта в директории 
создастся папка __pyache__, которая будет хранить байткод модуля.



Установка модулей с помощью pip

Для вывода всех уже скачанных модулей и их версий используется следующая команда:

pip list

Для установки модулей следующая команда:

pip install название_пакета

Для поиска python модулей используем сайт https://pypi.org
Код для вывода папки куда скачиваются модули:

import sys

print(sys.path[-1:])

Для установки сразу нескольких модулей можно использовать пакетную установку:

pip install -r текстовый_файл

Пример текстового файла:

accessify==0.3.1
autopep8==2.1.0
logging==0.4.9.6
pycodestyle==2.11.1
pygame==2.5.2

В этом обычном текстовом файле перечислины модули и их версии.
Для того чтоб вывести все установленные на ваш компьютер модули в пакет нужна след команда:

pip freeze > любой_файл.txt

 

Пакеты (package)

Пакет - это папка, в которой есть файл __init__.py
__init__.py - это инициализатор пакета.

Создадим пакет mypackage, в ней создадим __init__.py и перенесем туда файл time_fn.py, который
содержит функцию-декоратор который дополнительно выводит время исполнения функции.
Пакет выглядит след образом:

--mypackage
    __init__.py
    time_fn.py

И импортируем этот пакет в нужный файл (импорт пакетов происходит также как и импорт модулей)

__init__.py:

MESSAGE = "This is message from __init__.py"

1.py:

import mypackage

print(dir(mypackage))
# ['MESSAGE', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', 
# '__package__', '__path__', '__spec__']

Тут видно, что при импорте mypackage мы получаем доступ только к __init__.py, 
поэтому для получения доступа нужно импортировать в __init__.py все нужные модули.

__init__.py:

from mypackage.time_fn import time_fn

MESSAGE = "This is message from __init__.py"

1.py:

import mypackage

print(dir(mypackage))
# ['MESSAGE', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__',
# '__package__', '__path__', '__spec__', 'time_fn']

Здесь видно, что мы получили доступ к декоратору time_fn.
Также важно заметить что в __init__.py путь нужно указывать от корневой папки (mypackage.time_fn).
Это связано с тем, что пайтон рассматривает модули (включая __init__) относительно корневой папки, а не 
относительно друг друга. 
Но лучше будет импортировать все модули в __init__.py следующим образом:

from .time_fn import time_fn

В таком случае даже изменение названия пакета не повлияет на импорт.
. в импортах ссылается на текущую дерикторию.
Или же можно импортировать модули:

--mypackage
    __init__.py
    time_fn.py
    module1.py
    module2.py
    module3.py

__init__.py:

from . import module1, module2, module3

Также при импортах часто используют * и с помощью переменной __all__ можно определить что будет значить *
Example:

mymodule.py:

__all__ = ['name', 'surname', 'birthday']

name = 'Dmytro'
surname = 'Oleynik'
birthday = '19.10.2010'

other_value = 1

__init__.py:

from .mymodule import *

1.py:

import mypackage

print(dir(mypackage))
# ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__',
# '__path__', '__spec__', 'birthday', 'mymodule', 'name', 'surname']

Здесь видно что импортировались только те переменные, которые мы указали, а не все.
Также можно создавать вложенные пакеты:

--mypackage
    --subpackage
        __init__.py
        submodule.py
    module1.py
    module2.py
    module3.py

При такой директории вложенным пакетом является subpackage и при такой ситуации важно понимать, что 
нужно определить __init__ и для подпакета, и не забыть импортировать в основном __init__ подпакет.



Работа с файлами (function open)

У функции open есть три основных параметра:
    file - путь к файлу
    mode - режим доступа
    encoding - кодировка файла

Обязательным параметром является file.
Если указать неправельный путь будет ошибка FileNotFoundError.

.read() - нужен для чтения файлов 
По дефолту выводит полный файл но можно указать колво выводимых символов.

Важно указать кодировку UTF-8 если файл содержит не английские слова.
Также при использовании метода .read() в файле появляется файловая позиция. 
Пример:

# Hello, Dima :)
newfile = open('message.txt')
print(newfile.read(5))  # Hello
print(newfile.read(5))  # , Dim

Здесь четко видно как эта граница смещается.

.seek() - задает файловую позицию
Example:

# Hello, Dima :)
newfile = open('message.txt')
print(newfile.read(5))  # Hello
newfile.seek(0)
print(newfile.read(5))  # Hello
newfile.seek(7)
print(newfile.read(4))  # Dima

.tell() - выводит текущую файловую позицию.
Но тут есть предупреждение, если язык не английский то тогда файловая позицию может не соответствовать 
ожиданиям ведь с изменением кодировки один символ может хранить несколько байтов и изза этого файловая 
позицию будет сбиваться
Также есть метод .readline() который читает сразу одну строку.
Метод .readlines() возвращает список со строками.

Также важно в конце работы с файлом закрыть его (освободить память связанную с ним)

.close()



Контекстный менеджер with

Контекстный менеджер нужен для удобной работы с файлом

with открытие_файла as имя_переменной_для_файла:
    работа_с_файлом

Example:

with open('message.txt', mode='r', encoding='UTF-8') as message:
    message = message.readline()
    print(message)
# Hello, Dima :)

Для написания чего-то в файле его нужно открыть в режиме доступ w
Основные режимы доступа:
r - чтение файла.
w - открытие файла для записи (создает новый файл, с возможностю редактирования).
Также если файл уже существует он автоматически очистится.
a - для добавления чего-то нового в файл (без удаления предедущего).
Если добавить к режиму w или a, + тогда файл можно будет еще и читать.

Example:

try:  # всю работу с файлом обернем в try except
    with open('message.txt', mode='w+', encoding='UTF-8') as message:  # создаем файл в режиме записи и чтения
        message.write('Hello, World!')  # добавляем что-то
        message.seek(0)  # во время write файловая позиция смещается, поэтому нужно вернуть ее на место
        s = message.read()  # читаем файл
        print(s)  # Hello, World!

except:
    print('Error')  # обработка любой ошибки

Для записи в файл используется следующии методы:
.write() - запись чего-то
.writelines(["First string", "Second string"...]) - запись нескольких строк

Для того чтоб хранить определенные переменные в файлах используется бинарный тип доступа, до этого мы использовали
текстовый тип доступа.

Example:

import pickle  # импортируем библиотеку pickle
               # которая нужна для работы с бинарным типом доступа

info = {
    0: 'bread',
    1: 'milk',
    2: 'apple',
    3: 'cornflakes'
}

with open('out.bin', 'rb') as newfile:  # создаем файл с режимомо доступа wb
                                        # важно добавить b
    pickle.dump(info, newfile)    # dump нужен для загрузки переменных в файл
                                  # первым параметром нужно указать переменную, вторым файл
    info = pickle.load(newfile)   # теперь выгружаем все из файла
    print(info)                   # и выводим
    # {0: 'bread', 1: 'milk', 2: 'apple', 3: 'cornflakes'}



Выражения генераторы

Ранее мы создавали генераторы колекций (list comprehensions, dict comprehensions etc) 
Но можно создать генератор не привязываясь к определенному типу.

generator = (x for x in range(6))
print(generator)  # <generator object <genexpr> at 0x10e04c7c0>

И теперь мы можем приминить этот генератор к любому типу.

generator = (x for x in range(6))

listgen = list(generator)  # [0, 1, 2, 3, 4, 5]
setgen = set(generator)  # set()

Но почему во втором случае генератор не отработал?
Выражения генераторы - одноразовые. 

generator = (x for x in range(6))
listgen = list(generator)

generator = (x for x in range(6))
setgen = set(generator)

print(listgen)  # [0, 1, 2, 3, 4, 5]
print(setgen)  # {0, 1, 2, 3, 4, 5}

Теперь все работает.
Также к генераторам можно применять некоторые функции:

generator = (x for x in range(6))
print(max(generator))  # 5

generator = (x for x in range(6))
print(sum(generator))  # 15

В чем плюс генераторов?
Генераторы не хранят в себе ничего, кроме алгоритма, поэтому они занимают меньше памяти.
Они выполняют вычисления только тогда, когда это нужно.


Функции генераторы

До этого мы реализовывали выражения генераторы, которые действовали по определенному шаблону, 
но в пайтоне можно создавать свои генераторы.
По факту генератор это таже функция, но по которой можно проводить итерацию

# Простой пример генератора
def generator():
    yield 1  # ключевое слово yield выводит следующие значение последовательности

Если попробовать превратить этот генератор в список получится следующие

print(list(generator()))  # [1]

Попробуем вывести значение самого генератора

print(generator)  # <function generator at 0x109916340>

Главное отличие ключевого слова yield в генераторах от ключевого слова return в обычных функциях это
то, что код после yield выполняется.

def generator():
    yield 1
    print('codde after yield')  # codde after yield


print(list(generator()))

Также можно добавлять несколько yield в функцию генератор:

def generator():
    yield 1
    yield 2
    yield 3


print(list(generator()))  # [1, 2, 3]

Так можно увеличевать и усложнять генератор до потери пульса.
